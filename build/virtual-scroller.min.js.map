{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./library/find-element.js","webpack:///./library/sets.js","webpack:///./library/visibility-manager.js","webpack:///./library/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","BIAS_LOW","BIAS_HIGH","getBound","elements","edgeIndex","getRect","rect","Math","floor","bottom","top","findElementIndex","offset","bias","length","low","high","bound","findEdgeIndex","difference","a","b","result","Set","element","has","add","applyToDiffs","oldSet","newSet","deletedFunc","addedFunc","deleted","added","forEach","size","ElementBounds","constructor","this","first","last","expand","max","min","elementSet","nextElementSibling","EMPTY_ELEMENT_BOUNDS","USE_FALLBACK","getComputedStyle","document","createElement","subtreeVisibility","SizeManager","WeakMap","measure","oldSize","undefined","newSize","getBoundingClientRect","height","set","getHopefulSize","getAverageSize","remove","delete","VisibilityManager","container","containerComputedStyle","display","desiredLow","window","innerHeight","desiredHigh","newBounds","newRevealed","newObserved","previousElementSibling","previousAverage","previousScroll","scrollTop","scrollAdjustment","average","hidden","topIndex","style","paddingTop","paddingBottom","scrollBy","scheduleSync","sets","e","lastIndex","lowest","lowElementIndex","findElement","highElementIndex","index","classList","contains","bounds","observe","operation","reason","console","error","containIntrinsicSize","unobserve","scrollingElement","overflow","parentElement","children","IntersectionObserver","requestAnimationFrame","applyMutationObserverRecords","records","relevantMutation","toRemove","record","removedNodes","node","nodeType","Node","ELEMENT_NODE","toAdd","addedNodes","generateStyleSheet","styleSheet","type","textContent","styleSheetFactory","VirtualScrollerElement","HTMLElement","super","shadowRoot","attachShadow","adoptedStyleSheets","appendChild","visibilityManager","MutationObserver","childList","customElements","define"],"mappings":"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","file":"virtual-scroller.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * Copyright 2019 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n *\n * @fileoverview Utilities for binary searching by layed-out pixed offset in a\n * list of elements.\n * @package\n */\n\n/** Symbols for use with @see findElement */\nexport const BIAS_LOW = Symbol('BIAS_LOW');\nexport const BIAS_HIGH = Symbol('BIAS_HIGH');\n\nfunction getBound(elements, edgeIndex, getRect) {\n  const rect = getRect(Math.floor(edgeIndex / 2));\n  return edgeIndex % 2 ? rect.bottom : rect.top;\n}\n\n/**\n * Does the actual work of binary searching. This searches amongst the 2*N edges\n * of the N elements. Returns the index of an edge found, 2i is the low edge of\n * the ith element, 2i+1 is the high edge of the ith element. If |bias| is low\n * then we find the index of the lowest edge >= offset. Otherwise we find index\n * of the highest edge > offset.\n */\nfunction findEdgeIndex(elements, offset, bias, getRect) {\n  let low = 0;\n  let high = elements.length * 2 - 1;\n  while (low < high) {\n    const i = Math.floor((low + high) / 2);\n    const bound = getBound(elements, i, getRect);\n    if (bias === BIAS_LOW) {\n      if (bound < offset) {\n        low = i + 1;\n      } else {\n        high = i;\n      }\n    } else {\n      if (offset < bound) {\n        high = i;\n      } else {\n        low = i + 1;\n      }\n    }\n  }\n  return low;\n}\n\n/**\n * Binary searches inside the array |elements| to find an element containing or\n * nearest to |offset| (based on @see Element#getBoundingClientRect()). Assumes\n * that the elements are already sorted in increasing pixel order. |bias|\n * controls what happens if |offset| is not contained within any element or if\n * |offset| is contained with 2 elements (this only happens if there is no\n * margin between the elements). If |bias| is BIAS_LOW, then this selects the\n * lower element nearest |offset|, otherwise it selects the higher element.\n *\n * Returns null if |offset| is not within any element.\n *\n * @param {!Element[]} elements An array of Elements in display order,\n *     i.e. the pixel offsets of later element are higher than those of earlier\n *     elements.\n * @param {!number} offset The target offset in pixels to search for.\n * @param {!Symbol} bias Controls whether we prefer a higher or lower element\n *     when there is a choice between two elements.\n */\nexport function findElementIndex(elements, offset, bias, getRect) {\n  if (elements.length === 0) {\n    return -1;\n  }\n  // Check if the offset is outside the range entirely.\n  if (offset < getBound(elements, 0, getRect) ||\n      offset > getBound(elements, elements.length * 2 - 1, getRect)) {\n    return -1;\n  }\n\n  let edgeIndex = findEdgeIndex(elements, offset, bias, getRect);\n\n  // Fix up edge cases.\n  if (bias === BIAS_LOW) {\n    // bound(0)..bound(edgeIndex) < offset <= bound(edgeIndex+1) ...\n    // If we bias low and we got a low edge and we weren't exactly on the edge\n    // then we want to select the element that's lower.\n    if (edgeIndex % 2 === 0) {\n      const bound = getBound(elements, edgeIndex, getRect);\n      if (offset < bound) {\n        edgeIndex--;\n      }\n    }\n  } else {\n    // bound(0)..bound(edgeIndex - 1) <= offset < bound(edgeIndex) ...\n    // If we bias high and we got a low edge, we need to check if we were\n    // exactly on the edge of the previous element.\n    if (edgeIndex % 2 === 0) {\n      const bound = getBound(elements, edgeIndex - 1, getRect);\n      if (offset === bound) {\n        edgeIndex--;\n      }\n    }\n  }\n  return Math.floor(edgeIndex / 2);\n}\n","/**\n * Copyright 2019 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n *\n * @fileoverview Utility functions for set operations.\n * @package\n */\n\n/*\n * Returns the set of elements in |a| that are not in |b|.\n *\n * @param {!Set} a A set of elements.\n * @param {!Set} b A set of elements.\n */\nexport function difference(a, b) {\n  const result = new Set();\n  for (const element of a) {\n    if (!b.has(element)) {\n      result.add(element);\n    }\n  }\n  return result;\n}\n\n/**\n * Callback applying to an item in a set.\n *\n * @callback applyToDiff\n * @param {any} item\n */\n\n/**\n * Calculates the difference between |oldSet| and |newSet| and applies\n * |deletedFunc| or |addedFunc| to the elements that were deleted or added.\n *\n * Returns the number of elements operated on.\n *\n * @param {!Set} oldSet A set of elements.\n * @param {!Set} newSet A set of elements.\n * @param {applyToDiff} deletedFun A function to be applied to deleted elements.\n * @param {applyToDiff} addedFun A function to be applied to added elements.\n */\nexport function applyToDiffs(oldSet, newSet, deletedFunc, addedFunc) {\n  const deleted = difference(oldSet, newSet);\n  const added = difference(newSet, oldSet);\n  deleted.forEach(deletedFunc);\n  added.forEach(addedFunc);\n  return deleted.size + added.size;\n}\n","/**\n * Copyright 2019 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n *\n * @fileoverview This file provides the class backing the virtual-scroller\n *    element.\n * @package\n */\nimport * as findElement from './find-element.js';\nimport * as sets from './sets.js';\n\n\n// This controls how much above and below the current screen we\n// reveal, e.g. 1 = 1 screen of content.\nconst BUFFER = 0.2;\n// When we know about the heights of elements we default this height.\nconst DEFAULT_HEIGHT_ESTIMATE_PX = 100;\n// When we lock an element, we use this as the width. We use 1px because locked\n// items will not resize when their container changes and so could result in a\n// horizontal scroll-bar appearing if it they are wide enough.\nconst LOCKED_WIDTH_PX = 1;\n\n/**\n * Represents a range of elements from |low| to |high|, inclusive.\n * If either |low| or |high| are null then we treat this as an empty range.\n */\nclass ElementBounds {\n  /** @const {Element[]} */\n  elements;\n  /** @const {Number} */\n  low;\n  /** @const {Number} */\n  high;\n\n  constructor(elements, low, high) {\n    this.elements = elements;\n    this.low = low;\n    this.high = high;\n  }\n\n  first() {\n    if (this.low === -1)\n      return null;\n    return this.elements[this.low];\n  }\n\n  last() {\n    if (this.high === -1)\n      return null;\n    return this.elements[this.high];\n  }\n\n  size() {\n    if (this.low == -1 || this.high == -1)\n      return 0;\n    return this.high - this.low + 1;\n  }\n\n  expand(n) {\n    if (this.low == -1 || this.high == -1)\n      return;\n    this.low = Math.max(0, this.low - n);\n    this.high = Math.min(this.elements.length - 1, this.high + n);\n  }\n\n  // Returns a Set containing all of the elements from low to high.\n  elementSet() {\n    const result = new Set();\n    if (this.low === -1 || this.high === -1) {\n      return result;\n    }\n    let element = this.elements[this.low];\n    while (element) {\n      result.add(element);\n      if (element === this.elements[this.high]) {\n        break;\n      }\n      element = element.nextElementSibling;\n    }\n    return result;\n  }\n}\n\nconst EMPTY_ELEMENT_BOUNDS = new ElementBounds([], -1, -1);\nconst USE_FALLBACK = !getComputedStyle(document.createElement('div')).subtreeVisibility;\n\n/**\n * Manages measuring and estimating sizes of elements.\n *\n * This tracks an average measured element size as elements are added\n * and removed.\n */\nclass SizeManager {\n  #sizes = new WeakMap();\n\n  #totalMeasuredSize = 0;\n  #measuredCount = 0;\n\n  /**\n   * Measures and stores |element|'s size. If |element| was measured\n   * previously, this updates everything to use the new current size.\n   *\n   * @param {!Element} element The element to measure.\n   */\n  measure(element) {\n    let oldSize = this.#sizes.get(element);\n    if (oldSize === undefined) {\n      oldSize = 0;\n      this.#measuredCount++;\n    }\n    const newSize = element.getBoundingClientRect().height;\n    this.#totalMeasuredSize += newSize - oldSize;\n    this.#sizes.set(element, newSize);\n  }\n\n  /**\n   * Returns a size for |element|, either the last stored size or an\n   * estimate based on all other previously measured elements or a\n   * default.\n   *\n   * @param {!Element} element The element to produce a size for.\n   */\n  getHopefulSize(element) {\n    const size = this.#sizes.get(element);\n    return size === undefined ? this.getAverageSize() : size;\n  }\n\n  getAverageSize =\n      () => {\n        return this.#measuredCount > 0 ?\n            this.#totalMeasuredSize / this.#measuredCount :\n            DEFAULT_HEIGHT_ESTIMATE_PX;\n      }\n\n  /**\n   * Removes all data related to |element| from the manager.\n   *\n   * @param {!Element} element The element to remove.\n   */\n  remove(element) {\n    const oldSize = this.#sizes.get(element);\n    if (oldSize === undefined) {\n      return;\n    }\n    this.#totalMeasuredSize -= oldSize;\n    this.#measuredCount--;\n    this.#sizes.delete(element);\n  }\n}\n\n/**\n * Manages the visibility (locked/unlocked state) of a list of\n * elements. This list of elements is assumed to be in vertical\n * display order (e.g. from lowest to highest offset).\n *\n * It uses intersection observers to ensure that changes that impact\n * visibility cause us to recalulate things (e.g. scrolling,\n * restyling).\n */\nexport class VisibilityManager {\n  #sizeManager = new SizeManager();\n  #container;\n  #scroller;\n  #elements;\n  #revealedRange;\n  #syncRAFToken;\n\n  #intersectionObserver;\n\n  #revealed = new Set();\n  #observed = new Set();\n\n  constructor(container) {\n    this.#container = container;\n    this.#scroller = container;\n    while (this.#scroller != document.scrollingElement &&\n           getComputedStyle(this.#scroller).overflow == 'visible') {\n      this.#scroller = this.#scroller.parentElement;\n    }\n    this.#elements = container.children;\n\n    // We want to sync if any element's size changes or if it becomes\n    // more/less visible.\n    this.#intersectionObserver = new IntersectionObserver(() => {\n      this.scheduleSync();\n    });\n    this.#intersectionObserver.observe(container);\n\n    for (const element of this.#elements) {\n      this.#didAdd(element);\n    }\n    this.scheduleSync();\n  }\n\n  /**\n   * Attempts to unlock a range of elements suitable for the current\n   * viewport. This causes one forced layout.\n   */\n  #sync =\n      () => {\n        if (this.#elements.length === 0) {\n          return;\n        }\n\n        // Don't measure if the container is locked or not displayed.\n        const containerComputedStyle = getComputedStyle(this.#container);\n        if (containerComputedStyle.display == 'none' ||\n            containerComputedStyle.subtreeVisibility == 'hidden') {\n          return;\n        }\n\n        // The basic idea is ...\n        // The forced layout occurs at the start. We then use the laid out\n        // coordinates (which are based on a mix of real sizes for\n        // unlocked elements and the estimated sizes at the time of\n        // locking for locked elements) to calculate a set of elements\n        // which should be revealed. We use unlock/lock to move to this\n        // new set of revealed elements. We will check in the next frame\n        // whether we got it correct.\n\n        // This causes a forced layout and takes measurements of all\n        // currently revealed elements.\n        this.#measureRevealed();\n\n        // Compute the pixel bounds of what we would like to reveal. Then\n        // find the elements corresponding to these bounds.\n        // TODO(fergal): Use nearest scrolling ancestor?\n        const desiredLow = 0 - window.innerHeight * BUFFER;\n        const desiredHigh = window.innerHeight + window.innerHeight * BUFFER;\n        const newBounds = this.#findElementBounds(desiredLow, desiredHigh);\n        if (USE_FALLBACK)\n          newBounds.expand(1);\n        const newRevealed = newBounds.elementSet();\n\n        // This should include all of the elements to be revealed and\n        // also 1 element above and below those (if such elements\n        // exist).\n        const newObserved = new Set(newRevealed);\n        if (!USE_FALLBACK && newRevealed.size !== 0) {\n          const p = newBounds.first().previousElementSibling;\n          if (p) {\n            newObserved.add(p);\n          }\n          const n = newBounds.last().nextElementSibling;\n          if (n) {\n            newObserved.add(n);\n          }\n        }\n\n        // Having revealed what we hope will fill the screen. It\n        // could be incorrect. Rather than measuring now and correcting it\n        // which would involve an unknown number of forced layouts, we\n        // come back next frame and try to make it better. We know we can\n        // stop when we didn't hide or reveal any elements.\n        const previousAverage = this.#sizeManager.getAverageSize();\n        const previousScroll = this.#scroller.scrollTop;\n        if (this.#syncRevealed(newRevealed) + this.#syncObserved(newObserved) >\n            0) {\n          if (USE_FALLBACK) {\n            // Since we're changing the size of items above the viewport we\n            // need to adjust the scroll position to compensate.\n            let scrollAdjustment = 0;\n            const average = this.#sizeManager.getAverageSize();\n            const hidden = this.#revealedRange;\n            let topIndex = Math.floor(this.#scroller.scrollTop / average);\n            if (hidden && hidden.size()) {\n              topIndex = Math.min(topIndex, hidden.low);\n              for (let i = hidden.low; i < newBounds.low; i++) {\n                scrollAdjustment = scrollAdjustment - this.#sizeManager.getHopefulSize(this.#elements[i]) + previousAverage;\n              }\n            }\n            for (let i = newBounds.low; i < topIndex; i++) {\n              scrollAdjustment = scrollAdjustment + this.#sizeManager.getHopefulSize(this.#elements[i]) - previousAverage;\n            }\n\n            // Account for average size change\n            scrollAdjustment += (average - previousAverage) * newBounds.low;\n\n            // If we're not using subtree-visibility we need to adjust the padding\n            // of the container to account for the items which are hidden.\n            this.#container.style.paddingTop = (newBounds.low * average) + 'px';\n            this.#container.style.paddingBottom = ((this.#elements.length - newBounds.high - 1) * average) + 'px';\n\n            // Scroll anchoring may have already adjusted the scroll offset, so\n            // scroll by the difference from the current scroll top.\n            this.#scroller.scrollBy(0, previousScroll + scrollAdjustment - this.#scroller.scrollTop);\n            this.#revealedRange = newBounds;\n          }\n          this.scheduleSync();\n        }\n      }\n\n  /**\n   * Calls hide and reveal on child elements to take us to the new state.\n   *\n   * Returns the number of elements impacted.\n   */\n  #syncRevealed =\n      newRevealed => {\n        return sets.applyToDiffs(\n            this.#revealed, newRevealed, e => this.#hide(e),\n            e => this.#reveal(e));\n      }\n\n  /**\n   * Calls observe and unobserve on child elements to take us to the new state.\n   *\n   * Returns the number of elements impacted.\n   */\n  #syncObserved =\n      newObserved => {\n        return sets.applyToDiffs(\n            this.#observed, newObserved, e => this.#unobserve(e),\n            e => this.#observe(e));\n      }\n\n  /**\n   * Searches within the managed elements and returns an ElementBounds\n   * object. This object may represent an empty range or a range whose low\n   * element contains or is lower than |low| (or the lowest element\n   * possible). Similarly for |high|. If the bounds do not intersect with any\n   * elements then an EMPTY_ELEMENT_BOUNDS is returned, otherwise, if the\n   * |low| (|high|) is entirely outside the area of the managed elements\n   * then the low (high) part of the ElementBounds will be snapped to the\n   * lowest (highest) element.\n   *\n   * @param {!number} low The lower bound to locate.\n   * @param {!number} high The upper bound to locate.\n   */\n  #findElementBounds =\n      (low, high) => {\n        const lastIndex = this.#elements.length - 1;\n        const lowest = this.#getElementBounds(0).top;\n        const highest =\n            this.#getElementBounds(lastIndex).bottom;\n        if (highest < low || lowest > high) {\n          return EMPTY_ELEMENT_BOUNDS;\n        }\n\n        let lowElementIndex =\n            findElement.findElementIndex(this.#elements, low, findElement.BIAS_LOW, this.#getElementBounds.bind(this));\n        let highElementIndex = findElement.findElementIndex(\n            this.#elements, high, findElement.BIAS_HIGH, this.#getElementBounds.bind(this));\n\n        if (lowElementIndex === -1) {\n          lowElementIndex = 0;\n        }\n        if (highElementIndex === -1) {\n          highElementIndex = lastIndex;\n        }\n        return new ElementBounds(this.#elements, lowElementIndex, highElementIndex);\n      }\n\n  #getElementBounds =\n      (index) => {\n        if (!USE_FALLBACK || !this.#elements[index].classList.contains('hidden'))\n          return this.#elements[index].getBoundingClientRect();\n        // Otherwise, estimate bounding client rect.\n        let average = this.#sizeManager.getAverageSize();\n        let top = this.#container.getBoundingClientRect().top - this.#container.scrollTop;\n        let bounds = { top: index * average + top, bottom: (index + 1) * average + top};\n        if (this.#revealedRange && this.#revealedRange.size()) {\n          let offset = 0;\n          if (index < this.#revealedRange.low) {\n            offset = this.#revealedRange.first().getBoundingClientRect().top - (this.#revealedRange.low - index) * average - bounds.top;\n          } else if (index > this.#revealedRange.high) {\n            offset = this.#revealedRange.last().getBoundingClientRect().bottom + (index - this.#revealedRange.high - 1) * average - bounds.top;\n          }\n          bounds.top += offset;\n          bounds.bottom += offset;\n        }\n        return bounds;\n      }\n\n  /**\n   * Updates the size manager with all of the currently revealed\n   * elements' sizes. This will cause a forced layout.\n   */\n  #measureRevealed =\n      () => {\n        for (const element of this.#revealed) {\n          this.#sizeManager.measure(element);\n        }\n      }\n\n  /**\n   * Unlocks |element| so that it can be rendered.\n   *\n   * @param {!Element} element The element to reveal.\n   */\n  #reveal =\n      element => {\n        this.#revealed.add(element);\n        this.#unlock(element);\n      }\n\n  /**\n   * Observes |element| so that it coming on-/off-screen causes a sync.\n   *\n   * @param {!Element} element The element to observe.\n   */\n  #observe =\n      element => {\n        this.#intersectionObserver.observe(element);\n        this.#observed.add(element);\n      }\n\n  #logLockingError =\n      (operation, reason, element) => {\n        // TODO: Figure out the LAPIs error/warning logging story.\n        console.error(  // eslint-disable-line no-console\n            'Rejected: ', operation, element, reason);\n      }\n\n  /**\n   * Unlocks |element|.\n   *\n   * @param {!Element} element The element to unlock.\n   */\n  #unlock =\n      element => {\n        element.classList.remove('hidden');\n      }\n\n  /**\n   * Locks |element| so that it cannot be rendered.\n   *\n   * @param {!Element} element The element to lock.\n   */\n  #hide =\n      element => {\n        this.#revealed.delete(element);\n        if (!USE_FALLBACK) {\n          const size = this.#sizeManager.getHopefulSize(element);\n          element.style.containIntrinsicSize = `${LOCKED_WIDTH_PX}px ${size}px`;\n        }\n        element.classList.add('hidden');\n      }\n\n  /**\n   * Unobserves |element| so that it coming on-/off-screen does not\n   * cause a sync.\n   *\n   * @param {!Element} element The element to unobserve.\n   */\n  #unobserve =\n      element => {\n        this.#intersectionObserver.unobserve(element);\n        this.#observed.delete(element);\n      }\n\n  /**\n   * Notify the manager that |element| has been added to the list of\n   * managed elements.\n   *\n   * @param {!Element} element The element that was added.\n   */\n  #didAdd =\n      element => {\n        // Added children should be invisible initially. We want to make them\n        // invisible at this MutationObserver timing, so that there is no\n        // frame where the browser is asked to render all of the children\n        // (which could be a lot).\n        this.#hide(element);\n      }\n\n  /**\n   * Notify the manager that |element| has been removed from the list\n   * of managed elements.\n   *\n   * @param {!Element} element The element that was removed.\n   */\n  #didRemove =\n      element => {\n        // Removed children should be made visible again. We should stop\n        // observing them and discard any size info we have for them as it\n        // may have become incorrect. We unlock unconditionally,\n        // because it's simple and because it defends against\n        // potential bugs in our own tracking of what is locked. Users\n        // must not lock the children in the light tree, so there is\n        // no concern about this having an impact on the users'\n        // locking plans.\n        this.#unlock(element);\n        this.#revealed.delete(element);\n        this.#unobserve(element);\n        this.#sizeManager.remove(element);\n      }\n\n  /**\n   * Ensures that @see #sync() will be called at the next animation frame.\n   */\n  scheduleSync() {\n    if (this.#syncRAFToken !== undefined) {\n      return;\n    }\n\n    this.#syncRAFToken = window.requestAnimationFrame(() => {\n      this.#syncRAFToken = undefined;\n      this.#sync();\n    });\n  }\n\n  /**\n   * Applys |records| generated by a mutation event to the manager.\n   * This computes the elements that were newly added/removed and\n   * notifies the managers for each.\n   *\n   * @param {!Object} records The mutations records.\n   */\n  applyMutationObserverRecords(records) {\n    // It's unclear if we can support children which are not\n    // elements. We cannot control their visibility using display\n    // locking but we can just leave them alone.\n    //\n    // Relevant mutations are any additions or removals, including\n    // non-elements and also elements that are removed and then\n    // re-added as this may impact element bounds.\n    let relevantMutation = false;\n    const toRemove = new Set();\n    for (const record of records) {\n      relevantMutation = relevantMutation || record.removedNodes.length > 0;\n      for (const node of record.removedNodes) {\n        if (node.nodeType === Node.ELEMENT_NODE) {\n          toRemove.add(node);\n        }\n      }\n    }\n\n    const toAdd = new Set();\n    for (const record of records) {\n      relevantMutation = relevantMutation || record.addedNodes.length > 0;\n      for (const node of record.addedNodes) {\n        if (node.nodeType === Node.ELEMENT_NODE) {\n          if (toRemove.has(node)) {\n            toRemove.delete(node);\n          } else {\n            toAdd.add(node);\n          }\n        }\n      }\n    }\n    for (const node of toRemove) {\n      this.#didRemove(node);\n    }\n    for (const node of toAdd) {\n      this.#didAdd(node);\n    }\n\n    if (relevantMutation) {\n      this.scheduleSync();\n    }\n  }\n}\n","/**\n * Copyright 2019 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n *\n * @fileoverview This file defines virtual-scroller element.\n * EXPLAINER: https://github.com/WICG/virtual-scroller/blob/master/README.md\n * @package\n */\nimport {VisibilityManager} from './visibility-manager.js';\n\nfunction styleSheetFactory() {\n  let styleSheet;\n  return () => {\n    if (!styleSheet) {\n      styleSheet = document.createElement('style');\n      styleSheet.type = 'text/css';\n      styleSheet.textContent = `\n:host {\n  display: block;\n}\n\n::slotted(*) {\n  display: block !important;\n  contain: layout paint style !important;\n}\n::slotted(.hidden) {\n  display: none !important;\n}\n@supports (subtree-visibility: hidden) {\n  ::slotted(.hidden) {\n    display: block !important;\n    subtree-visibility: hidden;\n  }\n}\n`;\n    }\n    return styleSheet;\n  };\n}\n\nconst generateStyleSheet = styleSheetFactory();\n\n/**\n * The class backing the virtual-scroller custom element.\n */\nexport class VirtualScrollerElement extends HTMLElement {\n  constructor() {\n    super();\n\n    const shadowRoot = this.attachShadow({mode: 'closed'});\n    shadowRoot.adoptedStyleSheets = [generateStyleSheet()];\n    shadowRoot.appendChild(document.createElement('slot'));\n\n    const visibilityManager = new VisibilityManager(this);\n\n    new MutationObserver(records => {\n      visibilityManager.applyMutationObserverRecords(records);\n    }).observe(this, {childList: true});\n  }\n}\n\ncustomElements.define('virtual-scroller', VirtualScrollerElement);\n"],"sourceRoot":""}